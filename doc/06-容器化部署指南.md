# 百科Web应用 - 容器化部署指南

## 1. 概述

本文档介绍如何使用Docker和Docker Compose部署百科Web应用。容器化部署具有以下优势：
- 环境一致性
- 易于扩展
- 简化部署流程
- 便于维护

## 2. 前置要求

### 2.1 系统要求
- Linux/macOS/Windows
- Docker 20.10+
- Docker Compose 2.0+

### 2.2 硬件要求
- CPU: 2核心以上
- 内存: 4GB以上
- 磁盘: 20GB以上可用空间

## 3. 项目结构

```
dbapp/
├── docker/
│   ├── Dockerfile.frontend      # 前端Dockerfile
│   ├── Dockerfile.backend       # 后端Dockerfile
│   └── docker-compose.yml       # Docker Compose配置
├── nginx/
│   └── nginx.conf               # Nginx配置
├── frontend/                    # 前端项目
├── backend/                     # 后端项目
└── .env.example                 # 环境变量示例
```

## 4. Dockerfile编写

### 4.1 前端Dockerfile (docker/Dockerfile.frontend)

#### 4.1.1 多阶段构建（生产环境）
```dockerfile
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY frontend/package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY frontend/ .

# 构建应用
RUN npm run build

# 运行阶段
FROM nginx:alpine

# 复制构建产物到nginx
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx/nginx.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]
```

#### 4.1.2 开发环境Dockerfile
```dockerfile
FROM node:18-alpine

WORKDIR /app

# 复制package文件
COPY frontend/package*.json ./

# 安装依赖
RUN npm install

# 复制源代码
COPY frontend/ .

# 暴露端口
EXPOSE 3000

# 启动开发服务器
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
```

### 4.2 后端Dockerfile (docker/Dockerfile.backend)

#### 4.2.1 多阶段构建（生产环境）
```dockerfile
# 构建阶段
FROM golang:1.21-alpine AS builder

WORKDIR /app

# 安装构建依赖
RUN apk add --no-cache git

# 复制go mod文件
COPY backend/go.mod backend/go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY backend/ .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o api cmd/api/main.go

# 运行阶段
FROM alpine:latest

# 安装ca证书（用于HTTPS请求）
RUN apk --no-cache add ca-certificates tzdata

WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /app/api .

# 创建非root用户
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser && \
    chown -R appuser:appuser /app

USER appuser

# 暴露端口
EXPOSE 8080

# 启动应用
CMD ["./api"]
```

#### 4.2.2 开发环境Dockerfile
```dockerfile
FROM golang:1.21-alpine

WORKDIR /app

# 安装开发工具
RUN apk add --no-cache git make

# 安装air（热重载工具）
RUN go install github.com/cosmtrek/air@latest

# 复制go mod文件
COPY backend/go.mod backend/go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY backend/ .

# 暴露端口
EXPOSE 8080

# 使用air进行热重载
CMD ["air", "-c", ".air.toml"]
```

## 5. Docker Compose配置

### 5.1 docker-compose.yml
```yaml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    image: postgres:15-alpine
    container_name: dbapp-postgres
    environment:
      POSTGRES_DB: ${DB_NAME:-dbapp}
      POSTGRES_USER: ${DB_USER:-dbapp}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-dbapp123}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "${DB_PORT:-5432}:5432"
    networks:
      - dbapp-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-dbapp}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: dbapp-redis
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis123} --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "${REDIS_PORT:-6379}:6379"
    networks:
      - dbapp-network
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    restart: unless-stopped

  # 后端服务
  backend:
    build:
      context: .
      dockerfile: docker/Dockerfile.backend
    container_name: dbapp-backend
    environment:
      - GIN_MODE=release
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=${DB_USER:-dbapp}
      - DB_PASSWORD=${DB_PASSWORD:-dbapp123}
      - DB_NAME=${DB_NAME:-dbapp}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD:-redis123}
      - JWT_SECRET=${JWT_SECRET:-your-secret-key-change-in-production}
      - JWT_EXPIRES_IN=3600
      - FILE_UPLOAD_PATH=/app/uploads
    volumes:
      - backend_uploads:/app/uploads
      - ./backend:/app
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    networks:
      - dbapp-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  # 前端服务
  frontend:
    build:
      context: .
      dockerfile: docker/Dockerfile.frontend
    container_name: dbapp-frontend
    ports:
      - "${FRONTEND_PORT:-80}:80"
    networks:
      - dbapp-network
    depends_on:
      - backend
    restart: unless-stopped

  # Nginx反向代理（可选，如果需要统一入口）
  nginx:
    image: nginx:alpine
    container_name: dbapp-nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
    ports:
      - "${NGINX_PORT:-8000}:80"
    networks:
      - dbapp-network
    depends_on:
      - frontend
      - backend
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  backend_uploads:
    driver: local

networks:
  dbapp-network:
    driver: bridge
```

### 5.2 docker-compose.dev.yml（开发环境）
```yaml
version: '3.8'

services:
  postgres:
    # 同生产环境配置
    ports:
      - "5432:5432"

  redis:
    # 同生产环境配置
    ports:
      - "6379:6379"

  backend:
    build:
      context: .
      dockerfile: docker/Dockerfile.backend.dev
    environment:
      - GIN_MODE=debug
    volumes:
      - ./backend:/app
      - /app/vendor
    ports:
      - "8080:8080"
    command: air -c .air.toml

  frontend:
    build:
      context: .
      dockerfile: docker/Dockerfile.frontend.dev
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    command: npm run dev -- --host 0.0.0.0
```

## 6. Nginx配置

### 6.1 nginx/nginx.conf
```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;

    # 上游服务
    upstream backend {
        server backend:8080;
    }

    upstream frontend {
        server frontend:80;
    }

    # HTTP服务器
    server {
        listen 80;
        server_name localhost;

        # 前端静态文件
        location / {
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # API代理
        location /api/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket支持（如果需要）
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # 文件上传
        location /uploads/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
        }

        # 健康检查
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
```

## 7. 环境变量配置

### 7.1 .env.example
```bash
# 数据库配置
DB_HOST=postgres
DB_PORT=5432
DB_USER=dbapp
DB_PASSWORD=dbapp123
DB_NAME=dbapp

# Redis配置
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=redis123

# JWT配置
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=3600
JWT_REFRESH_IN=7200

# 服务器配置
BACKEND_PORT=8080
FRONTEND_PORT=80
NGINX_PORT=8000

# 文件上传配置
FILE_UPLOAD_PATH=/app/uploads
FILE_MAX_SIZE=10485760
FILE_ALLOWED_EXT=jpg,jpeg,png,gif,pdf,doc,docx

# 应用配置
APP_NAME=百科Web应用
APP_ENV=production
APP_DEBUG=false
```

### 7.2 创建.env文件
```bash
cp .env.example .env
# 编辑.env文件，修改配置
```

## 8. 部署步骤

### 8.1 开发环境部署

#### 8.1.1 启动服务
```bash
# 使用开发配置启动
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d

# 查看日志
docker-compose logs -f

# 查看服务状态
docker-compose ps
```

#### 8.1.2 数据库迁移
```bash
# 进入后端容器
docker-compose exec backend sh

# 运行迁移
./migrate up

# 或使用迁移脚本
docker-compose exec backend ./scripts/migrate.sh up
```

#### 8.1.3 访问服务
- 前端: http://localhost:3000
- 后端API: http://localhost:8080
- Nginx: http://localhost:8000

### 8.2 生产环境部署

#### 8.2.1 构建镜像
```bash
# 构建所有服务
docker-compose build

# 或单独构建
docker-compose build backend
docker-compose build frontend
```

#### 8.2.2 启动服务
```bash
# 启动所有服务
docker-compose up -d

# 查看启动日志
docker-compose logs -f

# 检查服务健康状态
docker-compose ps
```

#### 8.2.3 初始化数据库
```bash
# 等待数据库就绪
docker-compose exec postgres pg_isready -U dbapp

# 运行数据库迁移
docker-compose exec backend ./migrate up

# 创建初始管理员（如果需要）
docker-compose exec backend ./scripts/create_admin.sh
```

#### 8.2.4 验证部署
```bash
# 检查所有容器状态
docker-compose ps

# 检查服务健康
curl http://localhost:8000/health

# 检查API
curl http://localhost:8000/api/v1/health
```

## 9. 常用操作

### 9.1 服务管理
```bash
# 启动服务
docker-compose up -d

# 停止服务
docker-compose stop

# 停止并删除容器
docker-compose down

# 停止并删除容器和卷（谨慎使用）
docker-compose down -v

# 重启服务
docker-compose restart

# 重启特定服务
docker-compose restart backend
```

### 9.2 日志查看
```bash
# 查看所有服务日志
docker-compose logs -f

# 查看特定服务日志
docker-compose logs -f backend
docker-compose logs -f frontend

# 查看最近100行日志
docker-compose logs --tail=100 backend
```

### 9.3 进入容器
```bash
# 进入后端容器
docker-compose exec backend sh

# 进入数据库容器
docker-compose exec postgres psql -U dbapp -d dbapp

# 进入Redis容器
docker-compose exec redis redis-cli -a redis123
```

### 9.4 数据备份

#### 9.4.1 数据库备份
```bash
# 备份数据库
docker-compose exec postgres pg_dump -U dbapp dbapp > backup_$(date +%Y%m%d_%H%M%S).sql

# 或使用docker命令
docker exec dbapp-postgres pg_dump -U dbapp dbapp > backup.sql
```

#### 9.4.2 数据库恢复
```bash
# 恢复数据库
docker-compose exec -T postgres psql -U dbapp dbapp < backup.sql
```

#### 9.4.3 Redis备份
```bash
# Redis数据持久化在卷中，备份卷即可
docker run --rm -v dbapp_redis_data:/data -v $(pwd):/backup alpine tar czf /backup/redis_backup.tar.gz /data
```

### 9.5 更新部署
```bash
# 拉取最新代码
git pull

# 重新构建镜像
docker-compose build

# 停止旧容器
docker-compose down

# 启动新容器
docker-compose up -d

# 运行数据库迁移（如果有）
docker-compose exec backend ./migrate up
```

## 10. 监控和维护

### 10.1 资源监控
```bash
# 查看容器资源使用
docker stats

# 查看特定容器资源使用
docker stats dbapp-backend dbapp-frontend
```

### 10.2 健康检查
```bash
# 检查所有服务健康状态
docker-compose ps

# 手动健康检查
curl http://localhost:8000/health
curl http://localhost:8080/api/v1/health
```

### 10.3 清理操作
```bash
# 清理未使用的镜像
docker image prune -a

# 清理未使用的卷
docker volume prune

# 清理未使用的网络
docker network prune

# 清理所有未使用的资源
docker system prune -a
```

## 11. 故障排查

### 11.1 常见问题

#### 11.1.1 容器无法启动
```bash
# 查看容器日志
docker-compose logs [service_name]

# 检查端口占用
netstat -tulpn | grep [port]

# 检查配置文件
docker-compose config
```

#### 11.1.2 数据库连接失败
```bash
# 检查数据库容器状态
docker-compose ps postgres

# 检查数据库日志
docker-compose logs postgres

# 测试数据库连接
docker-compose exec backend ping postgres
```

#### 11.1.3 前端无法访问后端
```bash
# 检查网络连接
docker-compose exec frontend ping backend

# 检查后端服务
curl http://backend:8080/api/v1/health

# 检查Nginx配置
docker-compose exec nginx nginx -t
```

### 11.2 调试技巧
```bash
# 查看容器详细信息
docker inspect [container_name]

# 查看容器网络
docker network inspect dbapp_dbapp-network

# 查看容器环境变量
docker-compose exec backend env

# 实时查看日志
docker-compose logs -f --tail=50
```

## 12. 安全建议

### 12.1 生产环境配置
1. **修改默认密码**: 修改数据库、Redis的默认密码
2. **使用HTTPS**: 配置SSL证书，启用HTTPS
3. **限制网络访问**: 使用防火墙限制端口访问
4. **定期更新**: 定期更新Docker镜像和依赖
5. **备份策略**: 建立定期备份机制

### 12.2 环境变量安全
- 不要在代码中硬编码敏感信息
- 使用.env文件管理环境变量
- 生产环境使用密钥管理服务（如Vault）

### 12.3 容器安全
- 使用非root用户运行容器
- 限制容器资源使用
- 定期扫描镜像漏洞

## 13. 扩展部署

### 13.1 多实例部署
```yaml
# 扩展后端服务
docker-compose up -d --scale backend=3

# 扩展前端服务
docker-compose up -d --scale frontend=2
```

### 13.2 负载均衡
使用Nginx或Traefik进行负载均衡，配置多个后端实例。

### 13.3 数据库主从
配置PostgreSQL主从复制，实现读写分离。

## 14. Kubernetes部署（可选）

### 14.1 转换为K8s部署
如果需要使用Kubernetes部署，可以：
1. 使用kompose转换docker-compose.yml
2. 手动编写K8s YAML文件
3. 使用Helm Chart

### 14.2 示例命令
```bash
# 安装kompose
curl -L https://github.com/kubernetes/kompose/releases/download/v1.28.0/kompose-linux-amd64 -o kompose
chmod +x kompose
sudo mv ./kompose /usr/local/bin/kompose

# 转换docker-compose
kompose convert

# 部署到K8s
kubectl apply -f .
```

## 15. 附录

### 15.1 常用命令速查
```bash
# 启动
docker-compose up -d

# 停止
docker-compose stop

# 重启
docker-compose restart

# 查看日志
docker-compose logs -f

# 查看状态
docker-compose ps

# 进入容器
docker-compose exec [service] sh

# 构建镜像
docker-compose build

# 清理
docker-compose down -v
```

### 15.2 参考资源
- Docker官方文档: https://docs.docker.com/
- Docker Compose文档: https://docs.docker.com/compose/
- PostgreSQL Docker镜像: https://hub.docker.com/_/postgres
- Redis Docker镜像: https://hub.docker.com/_/redis

